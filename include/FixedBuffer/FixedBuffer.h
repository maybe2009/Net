/*
 * This Code is edited by sun wukong @ 2015.12.26 12:50:36 CST 
 * 
 * Just feel free to use this code as you wish.
 * Any bug and ugly code, please notify me, thanks!
 *
 * Github https://githuc.com/maybe2009
 * Gmail  qtdssunwukong@gmail.com
 * 									-Auto Generated By UltiSnips
 */

#ifndef OK_FIXEDBUFFER_INCLUDED
#define OK_FIXEDBUFFER_INCLUDED

#include "NetSocket.h"

#include <iostream>
#include <cstdio>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>

namespace ok {
#define KB(N) ((n) * 1024))
#define MB(n) ((n) * 1024 *1024)

size_t GetFileSize(int fd) {
  off_t ret = lseek(fd, 0, SEEK_END);
  size_t size = 0;
  if (ret == -1) {
    throw  NetSocketException(errno);
  } else {
    return (size = ret);
  }
}

class FixedBuffer {
public:
  typedef char BYTE;

public:
  FixedBuffer(size_t size)
      : m_capacity(size),
        m_available(size),
        m_water_meter(0),
        m_bottom(new BYTE[size]),
        m_current(m_bottom),
        m_end(m_bottom + size) {
  }

  ~FixedBuffer() {
    delete[]m_bottom;
  }

  void dump(int fd) {
    /*TODO add exception*/
    std::cout << "Dump :" << m_water_meter << std::endl;
    ::write(fd, m_bottom, m_water_meter);
  }

  void load(int fd, size_t len) {
    std::cout << "Read :" << std::endl;
    if (len <= m_available) {
      ::read(fd, m_current, len);
      moveMeters(len);
    }
  }

  void read(void *src, size_t index, size_t len) {
    //size_t end_index = start_index + len - 1; ---> be careful, if len = 0 , end_index will
    //overflow(unsigned) and maybe larger than m_capacity!
    //if len is too large, overflow shall occur
    if (index >= m_capacity || len >= m_capacity) {
      return;
    }

    size_t start_index = index;
    //TODO: start_index + len may overflow! fix it!
    size_t end_index = start_index + len;
    if (start_index < m_capacity && end_index <= m_capacity) {
      memcpy(src, m_bottom + start_index, len);
    }
  }

  void write(const void *src, size_t len) {
    if (len <= m_available) {
      memcpy(m_current, src, len);
      moveMeters(len);
    }
  }

  /**
   * @brief Set each byte to 0, reset all the argument like waterMeter_ etc.
   */
  void clear() {
    memset(m_bottom, 0, m_capacity);
    m_current = m_bottom;
    m_available = m_capacity;
    m_water_meter = 0;
  }

  /**
   * @brief Get the current available size in byte
   *
   * @return Current available bytes
   */
  size_t getAvailable() const {
    return m_available;
  }

  /**
   * @brief Get capacity
   *
   * @return Capacity
   */
  size_t getCapacity() const {
    return m_capacity;
  }

  /**
   * @brief Get watermeter indication which represents how many bytes there
   *        are in this buffer
   *
   * @return Watermeter indication
   */
  size_t getWaterMeter() const {
    return m_water_meter;
  }

  /*TODO: delete show() after debug*/
  void show() {
    //TODO:remove printf after test
    printf("Total size %ld Water Meter %ld Avai: %ld\n", m_capacity, m_water_meter, m_available);
    for (size_t i = 0; i < m_water_meter; ++i) {
      printf("P%ld:%c ", i, *(m_bottom + i));
    }
    printf("\n");
  }

private:

  /**
   * @brief When writting to buffer, use this function to adjust
   *corresponding indicators like watermeter etc. After this routine,
   *current_ index will move ahead for len bytes, available_ bytes will
   *reduce by len, waterMeter_ will rise for len
   *
   * @param len Thes number of bytes to be written
   */
  void moveMeters(size_t len) {
    m_current += len;
    m_available -= len;
    m_water_meter += len;
  }

private:
  const size_t m_capacity;
  size_t m_available;
  size_t m_water_meter;
  BYTE *const m_bottom;
  BYTE *m_current;
  BYTE *m_end;
};
};

#endif /* ifndef OK_FIXEDBUFFER_INCLUDED */

